/// <reference path="uglify-js.d.ts" />

declare const bb: IBB;

interface IBB {
    readContent(name: string): string;
    /// returns pipe delimited list of file names
    getPlainJsDependencies(name: string): string;
    writeBundle(name: string, content: string): void;
    generateBundleName(forName: string): string;
    resolveRequire(name: string, from: string): string;
    tslibSource(withImport: boolean): string;
    log(text: string): void;
}

interface IFileForBundle {
    name: string;
    ast: IAstToplevel;
    requires: string[];
    lazyRequires: string[];
    // it is not really TypeScript converted to commonjs
    difficult: boolean;
    json: boolean;
    shortname?: string;
    // empty string is main bundle
    partOfBundle: "" | string;
    selfexports: { name?: string; node?: IAstNode; reexport?: string }[];
    exports?: { [name: string]: IAstNode };
    pureFuncs: { [name: string]: boolean };
    plainJsDependencies: string[];
}

type FileForBundleCache = { [name: string]: IFileForBundle };

interface IBundleProject {
    mainFiles: string[];
    // default true
    compress?: boolean;
    // default true
    mangle?: boolean;
    // default false
    beautify?: boolean;
    defines?: { [name: string]: any };
}

/// bbRequirePath and bbExportedFrom cannot be used together.
interface ISymbolDefEx extends ISymbolDef {
    /// symbol of variable which was created by require(xxx) and bbRequirePath is resolved xxx
    bbRequirePath?: string;
    /// new name
    bbRename?: string;
    bbAlwaysClone?: boolean;
    /// symbol exported from cache[bbExportedFrom] (it means it is already lower cased)
    bbExportedFrom?: string;
}

function isRequire(symbolDef?: ISymbolDef) {
    return symbolDef != null && symbolDef.undeclared && symbolDef.global && symbolDef.name === "require";
}

function isPromise(symbolDef?: ISymbolDef) {
    return symbolDef != null && symbolDef.undeclared && symbolDef.global && symbolDef.name === "Promise";
}

function isReexport(symbolDef?: ISymbolDef) {
    return symbolDef != null && symbolDef.undeclared && symbolDef.global && symbolDef.name === "__exportStar";
}

function detectRequireCall(node: IAstNode | undefined): string | undefined {
    if (node instanceof AST_Call) {
        let call = <IAstCall>node;
        if (
            call.args!.length === 1 &&
            call.expression instanceof AST_SymbolRef &&
            isRequire((<IAstSymbolRef>call.expression).thedef)
        ) {
            let arg = call.args![0];
            if (arg instanceof AST_String) {
                return (<IAstString>arg).value;
            }
        }
    }
    return undefined;
}

//Detect this pattern and success return require const parameter
//Promise.resolve().then(function() {
//    return require("./lib");
//})
//Because this pattern is generated by TypeScript compiler when using: import("./lib")
function detectLazyRequireCall(node: IAstNode): string | undefined {
    if (node instanceof AST_Call && node.args != null && node.args.length === 1) {
        let then = node.expression;
        if (then instanceof AST_Dot && then.property === "then") {
            let resolveCall = then.expression;
            if (resolveCall instanceof AST_Call && (resolveCall.args == null || resolveCall.args.length === 0)) {
                let resolveExpr = resolveCall.expression;
                if (resolveExpr instanceof AST_Dot && resolveExpr.property === "resolve") {
                    let promiseRef = resolveExpr.expression;
                    if (!(promiseRef instanceof AST_SymbolRef) || !isPromise(promiseRef.thedef)) return undefined;
                } else return undefined;
            } else return undefined;
        } else return undefined;
        let argumentFunction = node.args[0];
        if (
            argumentFunction instanceof AST_Function &&
            (argumentFunction.argnames == null || argumentFunction.argnames.length === 0) &&
            argumentFunction.body != null
        ) {
            let body = argumentFunction.body;
            if (body.length === 1) {
                let returnStatement = body[0];
                if (returnStatement instanceof AST_Return) return detectRequireCall(returnStatement.value);
            }
        }
    }
    return undefined;
}

function isExports(node?: IAstNode) {
    if (node instanceof AST_SymbolRef) {
        let thedef = (<IAstSymbolRef>node).thedef;
        // thedef could be null because it could be already renamed/cloned ref
        if (thedef != null && thedef.global && thedef.undeclared && thedef.name === "exports") return true;
    }
    return false;
}

function matchPropKey(propAccess: IAstPropAccess): string | undefined {
    let name = propAccess.property;
    if (name instanceof AST_String) {
        name = (<IAstString>name).value;
    }
    if (typeof name === "string") {
        return name;
    }
    return undefined;
}

function patternAssignExports(node: IAstNode): { name: string; value?: IAstNode } | undefined {
    if (node instanceof AST_Assign) {
        let assign = <IAstAssign>node;
        if (assign.operator === "=") {
            if (assign.left instanceof AST_PropAccess) {
                let propAccess = <IAstPropAccess>assign.left;
                if (isExports(propAccess.expression)) {
                    let name = matchPropKey(propAccess);
                    if (name !== undefined) {
                        return {
                            name,
                            value: assign.right
                        };
                    }
                }
            }
        }
    }
    return undefined;
}

function patternDefinePropertyExportsEsModule(call: IAstCall) {
    //Object.defineProperty(exports, "__esModule", { value: true });
    if (call.args!.length === 3 && isExports(call.args![0])) {
        if (call.expression instanceof AST_PropAccess) {
            let exp = <IAstPropAccess>call.expression;
            if (matchPropKey(exp) === "defineProperty") {
                if (exp.expression instanceof AST_SymbolRef) {
                    let symb = <IAstSymbolRef>exp.expression;
                    if (symb.name === "Object") return true;
                }
            }
        }
    }
    return false;
}

function isConstantSymbolRef(node: IAstNode | undefined) {
    if (node instanceof AST_SymbolRef) {
        let def = (<IAstSymbolRef>node).thedef!;
        if (def.undeclared) return false;
        if (def.orig.length !== 1) return false;
        if (def.orig[0] instanceof AST_SymbolDefun) return true;
    }
    return false;
}

function promoteToIndependentLazyBundle(file: IFileForBundle, bundleName: string, cache: FileForBundleCache) {
    if (file.partOfBundle == bundleName) return;
    if (file.partOfBundle == "") return;
    file.partOfBundle = bundleName;
    file.requires.forEach(r => {
        promoteToIndependentLazyBundle(cache[r.toLowerCase()], bundleName, cache);
    });
}

function markRequiredAs(file: IFileForBundle, requiredAs: string, cache: FileForBundleCache) {
    if (file.partOfBundle !== requiredAs && file.partOfBundle !== "") {
        if (requiredAs === "") {
            file.partOfBundle = "";
        } else {
            // imported from 2 lazy bundles => promote to independent lazy bundle
            promoteToIndependentLazyBundle(file, file.name.toLowerCase(), cache);
        }
    }
}

function numberToChars(n: number) {
    let res = "";
    do {
        let rem = n % 26;
        res += String.fromCharCode(97 + rem);
        n = ((n / 26) | 0) - 1;
    } while (n >= 0);
    return res;
}

var globalDifficultCounter = 0;

function check(
    name: string,
    order: IFileForBundle[],
    visited: string[],
    cache: FileForBundleCache,
    requiredAs: string
): IFileForBundle {
    let cached: IFileForBundle = cache[name.toLowerCase()];
    if (cached !== undefined) return cached;

    let fileContent: string = bb.readContent(name);
    let jsdeps = bb.getPlainJsDependencies(name).split("|");
    if (jsdeps.length == 1 && jsdeps[0] == "") jsdeps = [];
    const cachedName = name.toLowerCase();
    const isJson = name.endsWith(".json");
    if (isJson) {
        let shortname = numberToChars(globalDifficultCounter++);
        cached = {
            name,
            shortname,
            ast: parse(`__bbe['${shortname}']=${fileContent};`),
            requires: [],
            lazyRequires: [],
            difficult: true,
            json: true,
            partOfBundle: requiredAs,
            selfexports: [],
            exports: undefined,
            pureFuncs: Object.create(null),
            plainJsDependencies: jsdeps
        };
        cache[cachedName] = cached;
        order.push(cached);
        return cached;
    }
    //bb.log("============== START " + name);
    //console.log(fileContent);
    let ast = parse(fileContent);
    //console.log(ast.print_to_string({ beautify: true }));
    ast.figure_out_scope!();
    cached = {
        name,
        ast,
        requires: [],
        lazyRequires: [],
        difficult: false,
        json: false,
        partOfBundle: requiredAs,
        selfexports: [],
        exports: undefined,
        pureFuncs: Object.create(null),
        plainJsDependencies: jsdeps
    };
    cache[cachedName] = cached;
    let pureMatch = fileContent.match(/^\/\/ PureFuncs:.+/gm);
    if (pureMatch) {
        pureMatch.forEach(m => {
            m.toString()
                .substr(m.indexOf(":") + 1)
                .split(",")
                .forEach(s => {
                    if (s.length === 0) return;
                    cached.pureFuncs[s.trim()] = true;
                });
        });
    }
    if (ast.globals!.has("module")) {
        cached.difficult = true;
        cached.shortname = numberToChars(globalDifficultCounter++);
        ast = parse(`(function(){ var exports = {}; var module = { exports: exports }; var global = this; ${fileContent}
__bbe['${cached.shortname}']=module.exports; }).call(window);`);
        cached.ast = ast;
        order.push(cached);
        return cached;
    }
    let unshiftToBody: IAstStatement[] = [];
    let selfExpNames = Object.create(null);
    let varDecls: IAstVarDef[] | null = null;
    let reexportDef: ISymbolDef | undefined;
    let walker = new TreeWalker((node: IAstNode, descend: () => void) => {
        if (node instanceof AST_Block) {
            (<IAstBlock>node).body = (<IAstBlock>node)
                .body!.map((stm): IAstStatement | undefined => {
                    if (stm instanceof AST_Directive && stm.value === "use strict") {
                        return undefined;
                    } else if (stm instanceof AST_SimpleStatement) {
                        let stmbody = (<IAstSimpleStatement>stm).body!;
                        let pea = patternAssignExports(stmbody);
                        if (pea) {
                            let newName = "__export_" + pea.name;
                            if (selfExpNames[pea.name] && stmbody instanceof AST_Assign) {
                                (<IAstAssign>stmbody).left = new AST_SymbolRef({
                                    name: newName,
                                    thedef: ast.variables!.get(newName)
                                });
                                return stm;
                            }
                            if (isConstantSymbolRef(pea.value)) {
                                selfExpNames[pea.name] = true;
                                let def = <ISymbolDefEx>(<IAstSymbolRef>pea.value).thedef;
                                def.bbAlwaysClone = true;
                                def.bbExportedFrom = cachedName;
                                cached.selfexports.push({
                                    name: pea.name,
                                    node: pea.value
                                });
                                return undefined;
                            }
                            let newVar = new AST_Var({
                                start: stmbody.start,
                                end: stmbody.end,
                                definitions: [
                                    new AST_VarDef({
                                        name: new AST_SymbolVar({
                                            name: newName,
                                            start: stmbody.start,
                                            end: stmbody.end
                                        }),
                                        value: pea.value
                                    })
                                ]
                            });
                            let symb = ast.def_variable!(newVar.definitions![0].name!);
                            symb.undeclared = false;
                            (<ISymbolDefEx>symb).bbAlwaysClone = true;
                            (<ISymbolDefEx>symb).bbExportedFrom = cachedName;
                            selfExpNames[pea.name] = true;
                            cached.selfexports.push({
                                name: pea.name,
                                node: new AST_SymbolRef({
                                    name: newName,
                                    thedef: symb
                                })
                            });
                            return newVar;
                        }
                        if (stmbody instanceof AST_Call) {
                            let call = <IAstCall>stmbody;
                            if (patternDefinePropertyExportsEsModule(call)) return undefined;
                            if (call.args!.length === 1 && call.expression instanceof AST_SymbolRef) {
                                let symb = <IAstSymbolRef>call.expression;
                                if (symb.thedef === reexportDef || isReexport(symb.thedef)) {
                                    let req = detectRequireCall(call.args![0]);
                                    if (req != null) {
                                        let reqr = bb.resolveRequire(req, name);
                                        if (cached.requires.indexOf(reqr) < 0) cached.requires.push(reqr);
                                        cached.selfexports.push({
                                            reexport: reqr
                                        });
                                        return undefined;
                                    }
                                }
                            }
                        }
                    } else if (stm instanceof AST_Defun) {
                        let fnc = <IAstFunction>stm;
                        if (fnc.name!.name === "__export") {
                            reexportDef = fnc.name!.thedef;
                            return undefined;
                        }
                    }
                    return stm;
                })
                .filter(stm => {
                    return stm != null;
                }) as IAstStatement[];
            descend();
            return true;
        }
        if (node instanceof AST_PropAccess) {
            if (!(walker.parent() instanceof AST_Assign) || !(walker.parent(1) instanceof AST_SimpleStatement)) {
                let propAccess = <IAstPropAccess>node;
                if (isExports(propAccess.expression)) {
                    let key = matchPropKey(propAccess);
                    if (key) {
                        if (selfExpNames[key]) return false;
                        let newName = "__export_" + key;
                        if (varDecls == null) {
                            let vartop = parse("var a;");
                            let stm = <IAstVar>vartop.body![0];
                            unshiftToBody.push(stm);
                            varDecls = stm.definitions!;
                            varDecls.pop();
                        }
                        let symbVar = new AST_SymbolVar({
                            name: newName,
                            start: node.start,
                            end: node.end
                        });
                        varDecls.push(
                            new AST_VarDef({
                                name: symbVar,
                                value: undefined,
                                start: node.start,
                                end: node.end
                            })
                        );
                        let symb = ast.def_variable!(symbVar);
                        symb.undeclared = false;
                        (<ISymbolDefEx>symb).bbAlwaysClone = true;
                        selfExpNames[key] = true;
                        cached.selfexports.push({
                            name: key,
                            node: new AST_SymbolRef({
                                name: newName,
                                thedef: symb,
                                start: node.start,
                                end: node.end
                            })
                        });
                        return false;
                    }
                }
            }
        }
        let result = detectLazyRequireCall(node);
        if (result != undefined) {
            let reqr = bb.resolveRequire(result, name);
            if (cached.lazyRequires.indexOf(reqr) < 0) {
                cached.lazyRequires.push(reqr);
            }
            return true;
        }
        let req = detectRequireCall(node);
        if (req != null) {
            let reqr = bb.resolveRequire(req, name);
            let parent = walker.parent();
            if (parent instanceof AST_VarDef) {
                let vardef = <IAstVarDef>parent;
                (<ISymbolDefEx>vardef.name!.thedef).bbRequirePath = reqr;
            }
            if (cached.requires.indexOf(reqr) < 0) cached.requires.push(reqr);
            return true;
        }
        return false;
    });
    ast.walk!(walker);
    ast.body!.unshift(...unshiftToBody);
    //console.log(ast.print_to_string({ beautify: true }));
    cached.requires.forEach(r => {
        const lowerR = r.toLowerCase();
        if (visited.indexOf(lowerR) >= 0) {
            markRequiredAs(cache[lowerR], cached.partOfBundle, cache);
            return;
        }
        visited.push(lowerR);
        check(r, order, visited, cache, cached.partOfBundle);
    });
    cached.lazyRequires.forEach(r => {
        const lowerR = r.toLowerCase();
        if (visited.indexOf(lowerR) >= 0) {
            markRequiredAs(cache[lowerR], lowerR, cache);
            return;
        }
        visited.push(lowerR);
        check(r, order, visited, cache, lowerR);
    });
    cached.exports = Object.create(null);
    cached.selfexports.forEach(exp => {
        if (exp.name) {
            cached.exports![exp.name] = exp.node!;
        } else if (exp.reexport) {
            let reexModule = cache[exp.reexport.toLowerCase()];
            if (reexModule.exports) {
                Object.assign(cached.exports, reexModule.exports);
            } else {
                reexModule.selfexports.forEach(exp2 => {
                    if (exp2.name) {
                        cached.exports![exp2.name] = exp2.node!;
                    }
                });
            }
        }
    });
    order.push(cached);
    return cached;
}

function renameSymbol(node: IAstNode): IAstNode {
    if (node instanceof AST_Symbol) {
        let symb = <IAstSymbol>node;
        if (symb.thedef == null) return node;
        let rename = (<ISymbolDefEx>symb.thedef).bbRename;
        if (rename !== undefined || (<ISymbolDefEx>symb.thedef).bbAlwaysClone) {
            symb = <IAstSymbol>symb.clone!();
            if (rename !== undefined) {
                symb.name = rename;
            }
            symb.thedef = undefined;
            symb.scope = undefined;
            symb.start = <any>{};
        }
        return symb;
    }
    return node;
}

function renameSymbolWithReplace(node: IAstNode, split: ISplitInfo): IAstNode {
    let imp = split.importsFromOtherBundles.get(node);
    if (imp !== undefined) {
        return imp[3]!.clone!();
    }
    return renameSymbol(node);
}

function emitGlobalDefines(defines: { [name: string]: any } | undefined): string {
    let res = "";
    if (defines == null) return res;
    let dns = Object.keys(defines);
    for (let i = 0; i < dns.length; i++) {
        res += "var " + dns[i] + " = " + JSON.stringify(defines[dns[i]]) + ";\n";
    }
    return res;
}

function captureTopLevelVarsFromTslibSource(bundleAst: IAstToplevel, topLevelNames: any) {
    bundleAst.figure_out_scope!();
    (<IAstFunction>(<IAstCall>(<IAstSimpleStatement>bundleAst.body![0]).body).expression).variables!.each(
        (val, key) => {
            if (key[0] == "_") topLevelNames[key] = true;
        }
    );
    bundleAst.globals!.each((val, key) => {
        topLevelNames[key] = true;
    });
}

interface ISplitInfo {
    /// lower cased file path
    fullName: string;
    /// created by bb.generateBundleName(this.fullName)
    shortName: string;
    /// name for __bbb property
    propName: string;
    /// __bbb.Value = Key;
    exportsUsedFromLazyBundles: Map<IAstNode, string>;
    /// from split, from file, export name, new AST_SymbolRef
    importsFromOtherBundles: Map<IAstNode, [ISplitInfo, IFileForBundle, string, IAstNode | undefined]>;
    /// map from fileName lower cased to __bbb property name
    exportsAllUsedFromLazyBundles: Map<string, string>;
    directSplitsForcedLazy: Set<ISplitInfo>;
    expandedSplitsForcedLazy: ISplitInfo[];
    plainJsDependencies: Set<string>;
}

type SplitMap = { [name: string]: ISplitInfo };
type NamesSet = { [name: string]: true };

var number2Ident = (function() {
    var leading = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split("");
    var digits = "0123456789".split("");
    var chars = leading.concat(digits);
    function base54(num: number) {
        var ret = "",
            base = 54;
        num++;
        do {
            num--;
            ret += chars[num % base];
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    }
    return base54;
})();

function bundle(project: IBundleProject) {
    globalDifficultCounter = 0;
    let order = <IFileForBundle[]>[];
    let visited: string[] = [];
    let cache: FileForBundleCache = Object.create(null);
    project.mainFiles.forEach(val => {
        const lowerVal = val.toLowerCase();
        if (visited.indexOf(lowerVal) >= 0) {
            markRequiredAs(cache[lowerVal], "", cache);
            return;
        }
        visited.push(lowerVal);
        check(val, order, visited, cache, "");
    });
    let bundleNames = [""];
    let splitMap: SplitMap = Object.create(null);
    splitMap[""] = {
        fullName: "",
        shortName: bb.generateBundleName(""),
        propName: "ERROR",
        exportsUsedFromLazyBundles: new Map(),
        importsFromOtherBundles: new Map(),
        exportsAllUsedFromLazyBundles: new Map(),
        directSplitsForcedLazy: new Set(),
        expandedSplitsForcedLazy: [],
        plainJsDependencies: new Set()
    };
    let lastGeneratedIdentId = 0;
    function generateIdent(): string {
        return number2Ident(lastGeneratedIdentId++);
    }
    order.forEach(f => {
        let fullBundleName = f.partOfBundle;
        if (bundleNames.indexOf(fullBundleName) < 0) {
            let shortenedBundleName = bb.generateBundleName(fullBundleName);
            bundleNames.push(fullBundleName);
            splitMap[fullBundleName] = {
                fullName: fullBundleName,
                shortName: shortenedBundleName,
                propName: generateIdent(),
                exportsUsedFromLazyBundles: new Map(),
                importsFromOtherBundles: new Map(),
                exportsAllUsedFromLazyBundles: new Map(),
                directSplitsForcedLazy: new Set(),
                expandedSplitsForcedLazy: [],
                plainJsDependencies: new Set()
            };
        }
        let jsDeps = splitMap[fullBundleName].plainJsDependencies;
        f.plainJsDependencies.forEach(v => jsDeps.add(v));
    });
    if (bundleNames.length > 1) detectBundleExportsImports(order, splitMap, cache, generateIdent);
    for (let bundleIndex = 0; bundleIndex < bundleNames.length; bundleIndex++) {
        let bundleAst = <IAstToplevel>(
            parse(
                '(function(undefined){"use strict";\n' +
                    bb.tslibSource(bundleNames.length > 1) +
                    (project.compress === false ? emitGlobalDefines(project.defines) : "") +
                    "})()"
            )
        );
        let bodyAst = (<IAstFunction>(<IAstCall>(<IAstSimpleStatement>bundleAst.body![0]).body).expression).body!;
        let pureFuncs: NamesSet = Object.create(null);
        let topLevelNames: NamesSet = Object.create(null);
        captureTopLevelVarsFromTslibSource(bundleAst, topLevelNames);
        let currentBundleName = bundleNames[bundleIndex];
        addAllDifficultFiles(order, currentBundleName, bodyAst);
        renameGlobalVarsAndBuildPureFuncList(order, currentBundleName, topLevelNames, pureFuncs);
        addExternallyImportedFromOtherBundles(bodyAst, splitMap[currentBundleName], topLevelNames);
        order.forEach(f => {
            if (f.partOfBundle !== currentBundleName) return;
            if (f.difficult) return;
            let transformer = new TreeTransformer(
                (node: IAstNode): IAstNode | undefined => {
                    if (node instanceof AST_Label) {
                        return node;
                    }
                    if (node instanceof AST_Symbol) {
                        let symb = <IAstSymbol>node;
                        if (symb.thedef == null) return undefined;
                        let rename = (<ISymbolDefEx>symb.thedef).bbRename;
                        if (rename !== undefined || (<ISymbolDefEx>symb.thedef).bbAlwaysClone) {
                            symb = symb.clone!();
                            if (rename !== undefined) symb.name = rename;
                            symb.thedef = undefined;
                            symb.scope = undefined;
                            return symb;
                        }
                        let reqPath = (<ISymbolDefEx>symb.thedef).bbRequirePath;
                        if (reqPath !== undefined && !(transformer.parent() instanceof AST_PropAccess)) {
                            let p = transformer.parent();
                            // don't touch declaration of symbol it will be removed in after function
                            if (p instanceof AST_VarDef && (<IAstVarDef>p).name === symb) return undefined;
                            let properties: IAstObjectKeyVal[] = [];
                            let extf = cache[reqPath.toLowerCase()];
                            if (!extf.difficult) {
                                let keys = Object.keys(extf.exports!);
                                keys.forEach(key => {
                                    properties.push(
                                        new AST_ObjectKeyVal({
                                            quote: "'",
                                            key,
                                            value: renameSymbolWithReplace(
                                                extf.exports![key],
                                                splitMap[currentBundleName]
                                            )
                                        })
                                    );
                                });
                                return new AST_Object({ properties });
                            }
                        }
                    }
                    if (node instanceof AST_PropAccess) {
                        let propAccess = <IAstPropAccess>node;
                        if (isExports(propAccess.expression)) {
                            let key = matchPropKey(propAccess);
                            if (key) {
                                let symb = f.exports![key];
                                if (symb) return renameSymbolWithReplace(symb, splitMap[currentBundleName]);
                            }
                        }
                    }
                    return undefined;
                },
                (node: IAstNode) => {
                    var req: string | undefined;
                    if (node instanceof AST_Block) {
                        let block = <IAstBlock>node;
                        block.body = block.body!.filter(stm => {
                            if (stm instanceof AST_Var) {
                                let varn = <IAstVar>stm;
                                if (varn.definitions!.length === 0) return false;
                            } else if (stm instanceof AST_SimpleStatement) {
                                let stmbody = (<IAstSimpleStatement>stm).body!;
                                if (detectRequireCall(stmbody) != null) return false;
                            }
                            return true;
                        });
                    }
                    if (node instanceof AST_Toplevel) {
                        let topLevel = <IAstToplevel>node;
                        bodyAst.push(...topLevel.body!);
                    } else if (node instanceof AST_Var) {
                        let varn = <IAstVar>node;
                        varn.definitions = varn.definitions!.filter(vd => {
                            return vd.name != null;
                        });
                    } else if (node instanceof AST_VarDef) {
                        let vardef = <IAstVarDef>node;
                        let thedef = <ISymbolDefEx>vardef.name!.thedef;
                        if (thedef && thedef.bbRequirePath) {
                            let extf = cache[thedef.bbRequirePath.toLowerCase()];
                            if (extf.difficult) {
                                vardef.value = (<IAstSimpleStatement>parse(`__bbe['${extf.shortname}']`).body![0]).body;
                            } else {
                                vardef.value = undefined;
                                vardef.name = undefined;
                            }
                        }
                    } else if (node instanceof AST_PropAccess) {
                        let propAccess = <IAstPropAccess>node;
                        if (propAccess.expression instanceof AST_SymbolRef) {
                            let symb = <IAstSymbolRef>propAccess.expression;
                            let thedef = <ISymbolDefEx>symb.thedef;
                            if (thedef && thedef.bbRequirePath) {
                                let extf = cache[thedef.bbRequirePath.toLowerCase()];
                                if (!extf.difficult) {
                                    let extn = matchPropKey(propAccess);
                                    if (extn) {
                                        let asts = extf.exports![extn];
                                        if (asts) {
                                            return renameSymbolWithReplace(asts, splitMap[currentBundleName]);
                                        }
                                        // This is not error because it could be just TypeScript interface
                                        // throw new Error("In " + thedef.bbRequirePath + " cannot find " + extn);
                                        return newSymbolRef("undefined");
                                    }
                                }
                            }
                        }
                    } else if ((req = detectLazyRequireCall(node))) {
                        let lowerCasedFullName = bb.resolveRequire(req, f.name).toLowerCase();
                        let file = cache[lowerCasedFullName];
                        let splitInfo = splitMap[file.partOfBundle];
                        let propName = splitInfo.exportsAllUsedFromLazyBundles.get(lowerCasedFullName);
                        if (splitInfo.fullName == "")
                            return new AST_Call({
                                args: [newSymbolRef("undefined"), new AST_String({ value: propName })],
                                expression: newSymbolRef("__import")
                            });
                        let resultAst = new AST_Call({
                            args: [new AST_String({ value: splitInfo.shortName }), new AST_String({ value: propName })],
                            expression: newSymbolRef("__import")
                        });
                        for (let i = splitInfo.expandedSplitsForcedLazy.length - 1; i >= 0; i--) {
                            let usedSplit = splitInfo.expandedSplitsForcedLazy[i];
                            resultAst = new AST_Call({
                                args: [
                                    new AST_Function({ argnames: [], body: [new AST_Return({ value: resultAst })] })
                                ],
                                expression: new AST_Dot({
                                    property: "then",
                                    expression: new AST_Call({
                                        args: [
                                            new AST_String({ value: usedSplit.shortName }),
                                            new AST_String({ value: usedSplit.propName })
                                        ],
                                        expression: newSymbolRef("__import")
                                    })
                                })
                            });
                        }
                        return resultAst;
                    }
                    return undefined;
                }
            );
            f.ast.transform!(transformer);
        });
        let currentSplit = splitMap[currentBundleName];
        appendExportedFromLazyBundle(bodyAst, currentSplit, cache);
        let jsDepAsts: IAstStatement[] = [];
        for (const jsDep of currentSplit.plainJsDependencies.keys()) {
            let depAst = parse(bb.readContent(jsDep));
            jsDepAsts = jsDepAsts.concat(depAst.body!);
        }
        if (jsDepAsts.length > 0) {
            bundleAst.body!.unshift(...jsDepAsts);
        }
        bundleAst = compressAst(project, bundleAst, pureFuncs);
        mangleNames(project, bundleAst);
        let out = printAst(project, bundleAst);
        if (bundleNames.length > 1 && bundleIndex === 0) {
            out = "var __bbb={};" + out;
        }
        bb.writeBundle(splitMap[currentBundleName].shortName, out);
    }
}

function addSplitImportExport(
    usesSplit: ISplitInfo,
    exportingFile: IFileForBundle,
    exportName: string,
    splitMap: SplitMap,
    generateIdent: () => string
) {
    if (usesSplit.fullName === exportingFile.partOfBundle) return;
    let exportingSplit = splitMap[exportingFile.partOfBundle];
    let astNode = exportingFile.exports![exportName];
    usesSplit.importsFromOtherBundles.set(astNode, [exportingSplit, exportingFile, exportName, undefined]);
    exportingSplit.exportsUsedFromLazyBundles.set(astNode, generateIdent());
}

function detectBundleExportsImports(
    order: IFileForBundle[],
    splitMap: SplitMap,
    cache: FileForBundleCache,
    generateIdent: () => string
) {
    order.forEach(f => {
        if (f.difficult) return;
        const sourceSplit = splitMap[f.partOfBundle];
        f.lazyRequires.forEach(lazyRequire => {
            let lowerCasedName = lazyRequire.toLowerCase();
            let targetSplit = splitMap[cache[lowerCasedName].partOfBundle];
            if (targetSplit.exportsAllUsedFromLazyBundles.get(lowerCasedName) !== undefined) return;
            if (targetSplit.fullName == lowerCasedName) {
                targetSplit.exportsAllUsedFromLazyBundles.set(lowerCasedName, targetSplit.propName);
            } else if (targetSplit.fullName == "") {
                targetSplit.exportsAllUsedFromLazyBundles.set(lowerCasedName, generateIdent());
            }
        });
        f.requires.forEach(require => {
            let lowerCasedName = require.toLowerCase();
            let targetSplit = splitMap[cache[lowerCasedName].partOfBundle];
            if (targetSplit !== sourceSplit && targetSplit.fullName !== "") {
                sourceSplit.directSplitsForcedLazy.add(targetSplit);
            }
        });
        let walker = new TreeWalker((node: IAstNode): boolean => {
            if (node instanceof AST_Symbol) {
                let symb = <IAstSymbol>node;
                if (symb.thedef == null) return false;
                let reqPath = (<ISymbolDefEx>symb.thedef).bbRequirePath;
                if (reqPath === undefined) return false;
                let extf = cache[reqPath.toLowerCase()];
                if (extf.difficult) return false;
                let p = walker.parent();
                if (p instanceof AST_PropAccess && typeof p.property === "string") {
                    addSplitImportExport(sourceSplit, extf, p.property, splitMap, generateIdent);
                } else if (p instanceof AST_VarDef && (<IAstVarDef>p).name === symb) {
                    return false;
                } else {
                    let keys = Object.keys(extf.exports!);
                    keys.forEach(key => {
                        addSplitImportExport(sourceSplit, extf, key, splitMap, generateIdent);
                    });
                }
                return false;
            }
            return false;
        });
        f.ast.walk!(walker);
    });
    var splitKeys = Object.keys(splitMap);
    for (let i = 0; i < splitKeys.length; i++) {
        let split = splitMap[splitKeys[i]];
        if (split.fullName == "") continue;
        expandDirectSplitsForcedLazy(split, split, new Set<ISplitInfo>().add(split));
    }
}

function expandDirectSplitsForcedLazy(split: ISplitInfo, rootSplit: ISplitInfo, visited: Set<ISplitInfo>) {
    split.directSplitsForcedLazy.forEach(targetSplit => {
        if (visited.has(targetSplit)) return;
        visited.add(targetSplit);
        expandDirectSplitsForcedLazy(targetSplit, rootSplit, visited);
    });
    if (split !== rootSplit) rootSplit.expandedSplitsForcedLazy.push(split);
}

function fileNameToIdent(fn: string): string {
    if (fn.lastIndexOf("/") >= 0) fn = fn.substr(fn.lastIndexOf("/") + 1);
    if (fn.indexOf(".") >= 0) fn = fn.substr(0, fn.indexOf("."));
    fn = fn.replace(/-/g, "_");
    return fn;
}

function newSymbolRef(name: string): IAstSymbolRef {
    return new AST_SymbolRef({ name, thedef: undefined, scope: undefined, start: <any>{} });
}

function addExternallyImportedFromOtherBundles(bodyAst: IAstStatement[], split: ISplitInfo, topLevelNames: NamesSet) {
    const importsMap = split.importsFromOtherBundles;
    let imports = Array.from(importsMap.keys());
    for (let i = 0; i < imports.length; i++) {
        let imp = importsMap.get(imports[i])!;
        let name = "__" + imp[2] + "_" + fileNameToIdent(imp[1].name);
        name = makeUniqueIdent(topLevelNames, name);
        imp[3] = newSymbolRef(name);
        let shortenedPropertyName = imp[0].exportsUsedFromLazyBundles.get(imports[i])!;
        bodyAst.push(
            new AST_Var({
                definitions: [
                    new AST_VarDef({
                        name: new AST_SymbolVar({
                            name,
                            thedef: undefined,
                            scope: undefined,
                            init: undefined,
                            start: <any>{}
                        }),
                        value: new AST_Dot({
                            expression: newSymbolRef("__bbb"),
                            property: shortenedPropertyName
                        })
                    })
                ]
            })
        );
    }
}

function makeUniqueIdent(topLevelNames: NamesSet, name: string) {
    let suffix = "";
    let iteration = 0;
    while (topLevelNames[name + suffix] !== undefined) {
        suffix = "" + ++iteration;
    }
    name += suffix;
    topLevelNames[name] = true;
    return name;
}

function renameGlobalVarsAndBuildPureFuncList(
    order: IFileForBundle[],
    currentBundleName: string,
    topLevelNames: NamesSet,
    pureFuncs: NamesSet
) {
    order.forEach(f => {
        if (f.partOfBundle !== currentBundleName) return;
        if (f.difficult) return;
        let suffix = fileNameToIdent(f.name);
        f.ast.globals!.each((val, key) => {
            topLevelNames[key] = true;
        });
        let walker = new TreeWalker((node: IAstNode, descend: () => void) => {
            if (node instanceof AST_Scope) {
                node.variables!.each((symb, name) => {
                    if ((<ISymbolDefEx>symb).bbRequirePath) return;
                    let newname = (<ISymbolDefEx>symb).bbRename || name;
                    if (
                        topLevelNames[name] !== undefined &&
                        (node === f.ast || node.enclosed!.some(enclSymb => topLevelNames[enclSymb.name] !== undefined))
                    ) {
                        let index = 0;
                        do {
                            index++;
                            newname = name + "_" + suffix;
                            if (index > 1) newname += "" + index;
                        } while (topLevelNames[newname] !== undefined);
                        (<ISymbolDefEx>symb).bbRename = newname;
                    } else {
                        (<ISymbolDefEx>symb).bbRename = undefined;
                    }
                    if (node === f.ast) {
                        if (name in f.pureFuncs) {
                            pureFuncs[newname] = true;
                        }
                        topLevelNames[newname] = true;
                    }
                });
            }
            return false;
        });
        f.ast.walk!(walker);
    });
}

function addAllDifficultFiles(order: IFileForBundle[], currentBundleName: string, bodyAst: IAstStatement[]) {
    let wasSomeDifficult = false;
    order.forEach(f => {
        if (f.partOfBundle !== currentBundleName) return;
        if (!f.difficult) return;
        if (!wasSomeDifficult) {
            let ast = parse("var __bbe={};");
            bodyAst.push(...ast.body!);
            wasSomeDifficult = true;
        }
        bodyAst.push(...f.ast.body!);
    });
}

function appendExportedFromLazyBundle(bodyAst: IAstStatement[], split: ISplitInfo, cache: FileForBundleCache) {
    split.exportsAllUsedFromLazyBundles.forEach((propName, lowerCasedFullName) => {
        let file = cache[lowerCasedFullName];
        let properties: IAstObjectKeyVal[] = [];
        let keys = Object.keys(file.exports!);
        keys.forEach(key => {
            properties.push(
                new AST_ObjectKeyVal({
                    quote: "'",
                    key,
                    value: renameSymbol(file.exports![key])
                })
            );
        });
        bodyAst.push(
            new AST_SimpleStatement({
                body: new AST_Assign({
                    operator: "=",
                    left: new AST_Dot({
                        expression: new AST_SymbolRef({
                            name: "__bbb"
                        }),
                        property: propName
                    }),
                    right: new AST_Object({ properties })
                })
            })
        );
    });
    split.exportsUsedFromLazyBundles.forEach((propName, valueNode) => {
        bodyAst.push(
            new AST_SimpleStatement({
                body: new AST_Assign({
                    operator: "=",
                    left: new AST_Dot({
                        expression: new AST_SymbolRef({
                            name: "__bbb"
                        }),
                        property: propName
                    }),
                    right: renameSymbol(valueNode)
                })
            })
        );
    });
}

function prependGlobalDefines(project: IBundleProject, out: string) {
    if (project.compress === false) {
        out = emitGlobalDefines(project.defines) + out;
    }
    return out;
}

function printAst(project: IBundleProject, bundleAst: IAstToplevel) {
    let os = OutputStream({
        beautify: project.beautify === true
    });
    bundleAst.print!(os);
    let out = os.toString();
    return out;
}

function compressAst(
    project: IBundleProject,
    bundleAst: IAstToplevel,
    pureFuncs: { [name: string]: true }
): IAstToplevel {
    if (project.compress !== false) {
        var start = Date.now();
        buildScopesAndLieAboutEval(bundleAst);
        let compressor = Compressor({
            hoist_funs: false,
            warnings: false,
            unsafe: true,
            collapse_vars: true,
            global_defs: project.defines,
            pure_funcs: call => {
                if (
                    call.start !== undefined &&
                    call.start.comments_before != null &&
                    call.start.comments_before.length === 1
                ) {
                    let c = call.start.comments_before[0];
                    if (c.type === "comment2" && (<string>c.value).indexOf("@class") >= 0) {
                        return false;
                    }
                }
                if (call.expression instanceof AST_SymbolRef) {
                    let symb = <IAstSymbolRef>call.expression;
                    if (
                        symb.thedef!.scope!.parent_scope != undefined &&
                        symb.thedef!.scope!.parent_scope!.parent_scope == null
                    ) {
                        if (symb.name! in pureFuncs) return false;
                    }
                    return true;
                }
                return true;
            }
        });
        bundleAst = <IAstToplevel>bundleAst.transform!(compressor);
        bb.log("Compress took " + ((Date.now() - start) * 0.001).toFixed(1) + "s");
    }
    return bundleAst;
}

function mangleNames(project: IBundleProject, bundleAst: IAstToplevel) {
    if (project.mangle !== false) {
        var start = Date.now();
        buildScopesAndLieAboutEval(bundleAst);
        base54.reset();
        bundleAst.compute_char_frequency!();
        bundleAst.mangle_names!();
        bb.log("Mangle took " + ((Date.now() - start) * 0.001).toFixed(1) + "s");
    }
}

function buildScopesAndLieAboutEval(bundleAst: IAstToplevel) {
    bundleAst.figure_out_scope!();
    let rootScope: IAstScope | undefined = undefined;
    let walker = new TreeWalker(n => {
        if (n !== bundleAst && n instanceof AST_Scope) {
            rootScope = n;
            return true;
        }
        return false;
    });
    bundleAst.walk!(walker);
    rootScope!.uses_eval = false;
    rootScope!.uses_with = false;
    bundleAst.uses_eval = false;
    bundleAst.uses_with = false;
}

function bbBundle(params: string) {
    bundle(JSON.parse(params) as IBundleProject);
}
